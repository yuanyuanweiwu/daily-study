# 1.从输入URL到页面展示发生了什么

1. 用户输入URL，浏览器会判断用户输入的信息是信息搜索还是网址，如果是搜索就是用默认引擎合成新URL；如果是符合URL规则就形成合法的URL。

2. 浏览器进程构建请求信息

3. 浏览器进程通过进程间通信（IPC）把URL发送至网络进程。

4. 网络进程在获取到URL，先会去本地缓存检查是否已经缓存了该资源，如果有将资源返回给浏览器进程

5. 如果没有，网络进程像web服务器发起HTTP请求，首先

   5.1 进行DNS解析获取IP地址，接下来利用IP地址建立TCP连接。(三次握手主要是通过判断ack是否等于seq+1)连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

   5.2  应用层HTTP解析请求头和请求体。如果需要重定向，HTTP直接返回状态码301或者302，同时在请求头的location字段附上重定向地址。如果不需要重定向，浏览器请求资源首先会判断是否命中强缓存（cache-control（http1.1）设定最大的有效时间，优先级高于->Expires（http1.0）设置过期时间）。如命中则返回状态码**200**，没命中（Cache-Control的值是no-cache），走协商缓存，过期直接请求资源。

   在协商缓存（Etag/If-None-Macth||Last-Modify/If-Modify-Since）中。两个都是实体标签表明资源的唯一性。服务端通过设置If-Modified-Since和If-None-Match，和客户端约定标识协商缓存的值。**一起用的话会优先判断Etag**。last-modify表示资源在服务器端最后更改的时间，如果资源没有更改返回**304**读取本地缓存，有更改返回200，最新资源。Etag的出现主要在于缓存文件的更改，可能在时间颗粒度上无法体现的问题，更倾向于一个md5。

   若以上缓存条件均不符合，服务端响应HTTP 200，返回更新后的数据，同时通过响应头更新 HTTP 缓存设置。

 ![](D:\学习\daily-study\JS高程\images\url.png)
6. 浏览器获取数据包后判断Content-type是text/html还是application/octet-stream，来进行准备渲染还是下载文件 。

7. 准备渲染进程，通常来讲一个页面一个进程，但如果属于同一站点，新页面会复用老页面进程。

8. 浏览器开始准备将网络层的数据提交到渲染进程
   首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；

   渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；

   等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；

   浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

9. 页面渲染主要包含以下几个流程--->解析-布局-绘制-光栅化
    1.解析。渲染进程首先解析HTML文本构建DOM树，解析CSS生成CSS规则树。

     2.布局。通过解析之后，渲染器进程知道每个节点的结构和样式，但如果需要渲染页面，浏览器还需要进   行布局，创建布局树后，进行分层

     3.绘制。渲染器主线程会遍历布局树进行绘制记录。如果树改变会触发重绘和重排。

     4.光栅化。通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。将这些信息转换为屏幕上的像素，这个过程被称为光栅化。合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图（GPU进程）。合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

------

#    2.消息队列与事件循环

每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。所以为了应对这种情况引入了事件循环机制->在线程运行过程中，能接收并执行新的任务。和消息队列->为了接受其他线程发送给主线程的信息，它主要是一种数据结构，符合队列先进先出的特点。**EvenetLoop主要是为了解决JS单线程会存在阻塞以及解决同步和异步任务管理的问题**![](D:\学习\daily-study\JS高程\images\浏览器事件循环.png)

浏览器中的EventLoop：

1. JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。

2. 同步任务会被放在调用栈中，按照顺序等待主线程依次执行。

3. 主线程之外存在一个回调队列(宏任务队列)，回调队列中的异步任务(宏任务)最终会在主线程中以调用栈的方式运行。

4. 同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 API，此时会产生一些异步任务。

5. 异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。

6. 调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。

事件循环中的异步回调队列有两种：宏任务（MacroTask）和微任务（MicroTask）队列。

什么是宏任务和微任务呢？

1. 宏任务：包括 script 全部代码、setTimeout、setInterval、setImmediate（Node.js）、requestAnimationFrame（浏览器）、I/O 操作、UI 渲染（浏览器），这些代码执行便是宏任务。

2. 微任务：包括process.nextTick（Node.js）、Promise、MutationObserver，这些代码执行便是微任务。


为什么要将异步任务分为宏任务和微任务呢？这是为了避免回调队列中等待执行的异步任务（宏任务）过多，导致某些异步任务（微任务）的等待时间过长。在每个宏任务执行完成之后，会先将微任务队列中的任务执行完毕，再执行下一个宏任务。

1. 因此，前面我们所说的回调队列可以理解为宏任务队列，同时还有另外一个任务队列为微任务队列。

2. 在浏览器的异步回调队列中，宏任务和微任务的执行过程如下：

3. 宏任务队列一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务。

4. 微任务队列中所有的任务都会被依次取出来执行，直到微任务队列为空。

5. 在执行完所有的微任务之后，执行下一个宏任务之前，浏览器会执行 UI 渲染操作、更新界面。


我们能看到，在浏览器中每个宏任务执行完成后，会执行微任务队列中的任务。而在 Node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。

```javascript
console.log("script start");
setTimeout(() => {
  console.log("setTimeout");
}, 1000);
Promise.resolve()
  .then(function () {
    console.log("promise1");
  })
  .then(function () {
    console.log("promise2");
  });
async function errorFunc() {
  try {
    await Promise.reject("error!!!");
  } catch (e) {
    console.log("error caught"); // 微1-3
  }
  console.log("errorFunc");
  return Promise.resolve("errorFunc success");
}
errorFunc().then((res) => console.log("errorFunc then res"));
console.log("script end");

//script start
//script end
//promise1
//error caught
//errorFunc
//promise2
//errorFunc then res
//settimeout
```

