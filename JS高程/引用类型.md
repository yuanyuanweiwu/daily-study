### 引用类型

#### 1.Object类型

#####    1.1创建object

创建Object类型的实例一般两种方式。第一种是 `var obj=new Objec()`，第二种是直接=后面接｛｝。以上两种方式，无论哪种他的原型都指向Object.prototype。于是有另外一种创建方式，可以自定义原型对象以及参数。**Object.create(proto,proprertiesObject)**

```javascript
var obj=Object.create(
    {a:1},
    {b:{value:1,          //对象属性的默认值，默认值为undefined
        writable:true,    //对象属性是否可修改,flase为不可修改，默认值为true
        configurable:true, //能否使用delete、能否需改属性特性、或能否修改访问器属性，false为不可                             重新定义，默认值为true
        enumerable:true   //对象属性是否可通过for-in循环，flase为不可循环，默认值为true
     }})
console.log(obj)
----------------------------
Object.create({})
{}      //值得注意当proto为空时，其创造出来的是一个空对象，并且没有原型，也就是没有继承                       Object.prototype上的方法
```

![](C:\Users\tim\Desktop\学习\daily-study\JS高程\images\Object.create.jpg)

可以看到对象obj的内容为`{b:1}`,它的原型对象上存在`a:1`的属性，我们可以自己模拟此方法，如下代码。

```javascript
//第一种
Object.newcreate=function(proto,proprertiesObject){
   // var F=new function(){}; //F==={}
    var F={};
    F.__proto__=proto;
    if(proprertiesObject){
        for( item in proprertiesObject ){
            F[item]=proprertiesObject[item].value
        }
    }
    return F
}
//第二种
Object.newcreate=function(proto,proprertiesObject){
  var F=function(){};
  F.prototype=proto;
  var obj=new F()
  if(proprertiesObject){
        Object.defineProperties(obj, proprertiesObject)
    }
   return obj;
}
```

##### 1.2定义对象属性

1. Object.defineProperty(obj,prop,descriptor)

   ```javascript
   var obj={}
   Object.defineProperty(obj,'name',{
       value:'TOM', 
       writable:true,
       configurable:true,
       enumable:true,
   })
   obj.name //TOM
   ```

2. Object.defineProperties(object, {prop1 : descriptor1, prop2 : descriptor2, ...)

   ```javascript
   var obj={}
   Object.defineProperty(obj,{'name':{
       value:'TOM',
       writable:true,
       configurable:true,
       enumable:true,
   }}，{'age':{
       value:'19',
       writable:true,
       configurable:true,
       enumable:true,
   }})
   obj.name //TOM 
   obj.age //19
   ```

##### 1.3 对象遍历的几种方法

1. Object.keys 遍历对象的属性。只包含对象本身可枚举属性，不包含原型链可枚举属性。

   ```javascript
   var obj={name:'tom',age:12};
   Object.keys(obj) //['name','age']
   ```

2. Object.values 遍历对象属性值。只包含对象本身可枚举属性，不包含原型链可枚举属性。

   ```javascript
   var obj={name:'tom',age:12};
   Object.values(obj) //['tom',12]
   ```

3. for...in  循环遍历对象自身和可继承的可枚举属性。 (最好不要用于数组循环，在老IE可能出现其他属性混杂到循环中)

   ```javascript
   var obj={name:'tom',age:12};
   for（let item in obj）{
       console.log(item,obj[item])
   }
   //name tom 
   //age 12 
   ```

4. Object.getOwnPropertyNames() 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名

   ```javascript
   var obj={name:'tom',age:12}；
   Object.getOwnPropertyNames(obj) //['name','age']
   ```

5. Object.getOwnPropertySymbols()  返回一个数组，包含对象自身的所有 Symbol 属性的键名。

6. Object.entries()  方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。

   ```javascript
   const obj={foo:'bar',baz:24}
   Object.entries(obj) //[['foo','bar'],['baz',23]]
   ```

7.  Reflect.ownKeys(obj)  返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

   以上方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

   - 首先遍历所有数值键，按照数值升序排列。
   - 其次遍历所有字符串键，按照加入时间升序排列。
   - 最后遍历所有 Symbol 键，按照加入时间升序排列。

   ```javascript
   Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
   // ['2', '10', 'b', 'a', Symbol()]
   ```

   上面代码中，`Reflect.ownKeys`方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性`2`和`10`，其次是字符串属性`b`和`a`，最后是 Symbol 属性。

##### 1.4 原型对象相关

1. getPrototypeOf  获取指定对象原型

   ```javascript
   var obj=Object.create({})
   Object.getPrototypeOf(obj)==={} //true
   Object.getPrototypeOf( Object ) === Function.prototype;  // true
   ```

2. setPrototypeOf 设置一个指定的对象的原型

   ```javascript
   let obj={a:1}; proto={b:1}
   Object.setPrototype(obj,proto)
   obj.__proto__===proto //true	
   ```

##### 1.5属性相关

1. getOwnPropertyNames 

2. getOwnPropertyDescriptor 

   ```javascript
   let obj = { foo: 123 };
   Object.getOwnPropertyDescriptor(obj, 'foo')
   //  { value: 123, writable: true, enumerable: true, configurable: true }
   ```

3. getOwnPropertyDescriptors 返回指定对象所有自身属性（非继承属性）的描述对象

   ```javascript
   const obj = {
     foo: 123,
     get bar() { return 'abc' }
   };
    
   console.dir(Object.getOwnPropertyDescriptors(obj))
   //   { foo:{ value: 123,
   //      writable: true,
   //      enumerable: true,
   //      configurable: true },
   //     bar:{ get: [Function: bar],
   //      set: undefined,
   //      enumerable: true,
   //      configurable: true } 
   //     }
   ```

##### 1.6 复制对象

Object.assign(target,source,source1) 方法用于对象的合并，将源一个或多个源对象（source）的所有可枚举属性，复制到目标对象（target）。拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）

```javascript
let target={}
let source={a:1,b:2}
let source1={c:3}
Object.assign(target,source,source1) //{a: 1, b: 2, c: 3}
---------------------
//注意此拷贝不是深拷贝
let source2={d:{e:1}}
Object.assign(target,source2)        // {d:{e:1}}
source2.d.e=2
target.d.e==2                        //true
```

##### 1.7  Object.is()

ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。

ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。

```javascript
Object.is('foo', 'foo')
// true
Object.is({}, {})
// false
--------------------------
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
```

------

#### 2.Array类型

