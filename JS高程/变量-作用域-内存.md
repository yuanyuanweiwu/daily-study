# 变量-作用域-内存

### 1.变量类型

  JS中存在两种变量类型。一种是值类型、一种是引用类型。

​        基本数据类型(值类型)：undefined、null、Boolean、number、string、Symbol

​	引用类型：Object、Array、Date、RegExg、Function

  在对变量进行赋值时。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，及两个变量虽然数值一样，但是都是存在栈空间上的**完全独立存在**。如果是引用类型的赋值  ，同样是将存储在变量对象的值复制一份放在新变量的分配空间。但实际上这个值的副本是一个指向原存储在堆空间对象的一个**指针**，在这里如果你对原对象的属性进行修改，所赋值的新对象的属性值依然会被覆盖。

  ECMAScript中所有的函数参数都是按照值传递的，相当于开辟了一块的新的空间也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样，如下所示。

```javascript
function addTen(num) { 
 num += 10; 
 return num; 
} 

var count = 20; 
var result = addTen(count); 
alert(count); //20，没有变化
alert(result);
```

​	在这个例子中,定义的`count`为值类型,调用函数`addTen`。这里传入时，先将`count`的值复制给参数`num`，在函数中`num`就相当于函数的局部变量，因此两个变量仅仅是数值的相同，本身是完全独立的。函数内部的变量改动不会影响函数外部的变量。同理 ，如果是传入的是引用类型。复制的是指向相同对象的地址。所以，内部改变，会影响到外部变量。这里就会牵扯到一个问题，那还是按照值类型传递么？按以下代码分析

```javascript
function setName(obj) {
obj.name = "Nicholas";
obj = new Object();
obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```

 	 在这个例子中创建了一个对象并将其保存在变量`person`中，然后将其复制给了参数`object`,这里两个对象引用的是同一个对象。因此 赋值了`name`之后 外部的`person`就会有了属性值。但是在函数中后面又将`obj`赋值了一个新的对象，并同样赋值了`name `属性，为什么在外部没有被修改嘞？这说明，即使在函数内部修改了参数的值，但原始的引用仍然保持未变。当在函数内部重写` obj` 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 **最简单的一句话讲就是引用类型的按照值传递，它这个值仅仅就是是内存地址指针，你替换的是在栈空间的一个指向对象，而不是去堆空间更改原对象**

*引用<https://www.jqhtml.com/45272.html>可进一步解释。*

#### 1.1检测类型

1. typeof 主要用于判断基本值类型,null例外。但是在引用类型的判断时会判全部判断成object。

2. instanceof 用于判断引用类型的值，用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，因存在原型链的缘故。实例对象的__proto__指向了原型对象，而原型对象上的constructor属性又指回了构造函数。相当于从两边去找共同引用。如果找到，判断为true。如果是值类型则全是false

3. constructor   是Object 类型的原型属性，它能够返回当前对象的构造器。但值得注意的是constructor可以被更改，所以是不安全的，undefined、null没有constructor方法。

4. Object.prototype.toString.call 因为所有引用类型的类都是集成于Object，所以你可以调用父辈的prototype上的方法，如

   ```javascript
   Object.prototype.toString()           //'[Object Object]'
   Object.prototype.toString().call(arr) //'[Object Array]'
   ```

   但是每个类都自己重写了这个方法,所以在判断的时候最后的Object会转换为自己的类型,所以调用此方法，讲call指向想要执行的对象，进行判断。但是这里如果是判断object的话，会出现上面的情况，看不出来 ，最好用instanceof

#### 1.2 变量提升

```javascript
console.log(a);
var a = 1;// 输出 undefined
===
var a 
console.log(a)
a=1
-------------------------------
console.log(foo);//输出函数foo
function foo(){
 
}
```

由上可知，标识符var和函数都会存在变量提升，在ES6中，新定义了let和const两个标识符，作用在于申明块级作用域。如果类似于上面的代码，把var换成let，将输出`a is not defined`。

*可参考<https://segmentfault.com/a/1190000019338567>*

------

### 2.执行环境

执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围环境，在web浏览器中即windows对象。局部环境是每个函数自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。因此会形成一个作用域链。内部环境变量可依次向上寻找，找到最外层windows为止。

在ES6之前，JS没有块级作用域。如下面代码所示。

```javascript
if (true) { 
 var color = "blue"; 
} 
alert(color); //"blue"

for (var i=0; i < 10; i++){ 
 doSomething(i); 
} 
alert(i); //10
```

第一段代码中,if声明的变量会添加到最近的环境中,即windows对象。所以外部仍能访问。第二段同理，定义的i即使是在整个for执行完后依旧是在外部的执行环境中，所以,他不能每次独立 ，而是循环的都是访问的最外环境的值。

对于标识符的查询。会沿作用域链，向上查找。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

------

### 3.垃圾回收

待写