# 对象的创建与继承

### 1理解对象

 首先对于对象的属性来讲，它具有四个描述性的特征。

- `Configurable`表示能否通过delete来删除属性并重新定义，能否修改属性，或者能否把属性修改为访问器属性，默认值是true。
- `Enumerable`可枚举类型表示，能否通过for...in进行遍历，默认值为true
- `Writebale`表示能否修改属性的值
- `Value`包含这个属性的值

一般来说，你可以通过`object.defineProperty()`来对属性进行设置。另外一种是访问器属性。同样包含四个属性描述特征，其中`Writebale`，`Value`,改成了`get`,`set`接受一个函数，返回想要的值。

### 2创建对象

通常来说，我们创建对象一般是用对象字面量。但是，大量创建就会产生重复代码，所以，我们开始使用工厂模式进行创建。(*工厂模式相当于，我给你想要的原材料，你就能给我生产出需要的东西，至于怎么生产我不管*)

```javascript
function person(name,age){
    var o=new Object();
    o.name=name;
    o.age=age;
    return o
}
var person1=person('tom',12)  //{name:'tom',age:12}
```

但是后面，又因为存在不知道对象类型的问题，而又产生新的模式-----构造函数

```javascript
function Person(name,age){
    this.name=name;
    this.age=age
}
var person=new Person('tom',12)  //{name:'tom',age:12}
```

在构造函数中我们不用担心他的函数类型的要求。创建过程依赖于外部new。以这种方式调用构造函数会经过下面四个步骤：

- 创建了一个新的对象
- 将构造函数的作用域赋给新对象即this指向了这个新对象
- 执行构造函数代码，为这个对象添加属性
- 返回这个新对象

但是构造函数同样存在问题，即如果设定一个属性为一个new Function。那会导致每个实例都要创建这个方法，造成性能的浪费。所以，最后我们将方法定义在原型对象上。下面具体总结一下构造函数-原型对象-实例的问题。

### 3原型

我们创建的每个函数都包含一个`prorotype`属性指向一个对象，这个对象称之为原型对象，它包含可以有特定类型的所有实例共享的属性和方法。

```javascript
function Person(){ 
} 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function(){ 
 alert(this.name); 
}; 
var person1 = new Person(); 
person1.sayName(); //"Nicholas"
```

![](C:\Users\tim\Desktop\学习\daily-study\JS高程\images\prototype.jpg)

我么可以通过上图进行分析。首先无论什么时候，只要创建了一个新的函数，他都会根据一组特定的规则创建一个Prototype属性，这个属性指向函数的原型对象。同事原型对现象上会自动获得一个constructor属性，这个属性包含一个指针指向构造函数。在创建实例后，这个实例会包含一个指针`__proto__`指向原型对象。所以实例可以去访问这个原型对象上定义的方法。

因此，在访问方法，属性定义上就存在一个寻找链的关系，即现在实例对象上寻找，如果没找到就向这个实例对象的原型对象上去寻找。如果两个都有相同的属性，找到了实例上的就不会继续向上寻找。这里我们可以使用 `hasOwnProperty()`方法可以检测一个属性是存在于实例中，还是存在于原型中。

当然，对于原型对象，我们是可以修改的。如果将原型对象赋值一个新的对象。相当于重写原型对象。此时，他的`constructor`属性将不再指向原构造函数，现在的情况是指向了`Object`。

```javascript
function Person(){}
var person =new Person()
Person.prototype={
    constructor:Person
    name:'tom'
}
person.tom   //undefined
```

在这个例子中我们即使将原型对象重写了，constructor指回了原构造函数，实例依然无法读取原型对象上的属性。**这是因为实例化时，添加的指针指向的是最初的原型对象，一旦更改原型对象后，就切断了之前任何实例与现有原型之间的关系，他们仍然指向最初的原型对象。**

### 4原型链

关于原型链，主要在于模仿其他高级语言的继承。即想一个引用类型继承另一个引用类型的方法。通常来说就是让一个原型对象等于另一个类型的实例来构建原型链关系。

```javascript
function SuperType(){
    this.property=true
}
SuperType.prototype.getSuperValue=function(){
    return this.property
}
function SubType(){
    this.subproperty=false
}
SubType.prototype=new SuperType()

SubType.prototype.getSubValue=function(){
    return this.subproperty
}
var instance=new Son()
instance.getSuperValue()    //true
instance.getSubValue()       //false
```

由以上代码可知，在原型链继承后。Son的实例对象可以使用Father原型对象上定义的方法。具体分析，按照高程所示图进行解释。

![](C:\Users\tim\Desktop\学习\daily-study\JS高程\images\原型链1.jpg)

首先我们知道`SubType`的实例对象`instance`的`__proto__`指向了``SubType``的原型对象。现在让``SubType``的原型对象等于`SuperType`的实例对象。我们便得到了`SuperType`的实例对象的`__proto__`指针，它的指针当然指向了`SuperType`的原型对象，所以我们``SubType``的原型对象现在指向了`SuperType`的原型对象，并且由于现在还是实例化的对象，所以我们可得到全部`SuperType`构造函数定义的属性以及原型对象定义的方法。

```javascript

```

